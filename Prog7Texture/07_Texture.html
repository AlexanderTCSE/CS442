<!DOCTYPE html>
<html>
    <head>
        <title>Mesh Viewer v1.3</title>
        <style>
            #the-canvas { border: 1px solid darkblue; }
        </style>
    </head>

    <body>
        <canvas id = "the-canvas" width = "800" height = "600"></canvas>
		<script src="matrix.js"></script>
		<script src="vector.js"></script>
        <script src="mesh.js"></script>
        <script src="controls.js"></script>
        <script src="cam.js"></script>
        <script src = "lib.js"></script>
        
        <script>
            //keylog
            const keys = Keys.start_listening();
            //game update intervals
            const DESIRED_TICK_RATE = 60;
            const DESIRED_MSPT = 1000/DESIRED_TICK_RATE;

            let canvas = document.getElementById( 'the-canvas' );
            let gl = canvas.getContext( 'webgl2' );

			const XY_ROT_SPEED=0.125;
			const XZ_ROT_SPEED=0.125;
			const YZ_ROT_SPEED=0.125;
			
			let xy_amnt=0.0;
			let xz_amnt=0.0;
			let yz_amnt=0.0;
			let last_update=performance.now();

            let rot_xy = Mat4.identity();
            let rot_xz = Mat4.identity();
            let rot_yz = Mat4.identity();
            let translationMatrix = Mat4.identity();

			let modelxy=Mat4.rotation_xy(XY_ROT_SPEED);
            let modelxz=Mat4.rotation_xz(XZ_ROT_SPEED);
            let modelyz=Mat4.rotation_yz(YZ_ROT_SPEED);
            let model=Mat4;


            
            let vertex_source = 
            `   #version 300 es
                precision mediump float;

				uniform mat4 modelview;

                in vec3 coordinates;	//input XY coords from verts
				in vec4 color;			//input color from verts
				out vec4 fragColor;		//output fragColor to fragment shader
				
                void main( void ) {
                    gl_Position = modelview*vec4( coordinates, 1.0 );
					fragColor=color;
                }
            `;

            let vert_shader = gl.createShader( gl.VERTEX_SHADER );
            gl.shaderSource( vert_shader, vertex_source );
            gl.compileShader( vert_shader );


            let fragment_source = 
            `   #version 300 es
                precision mediump float;

                in vec4 v_color;

                out vec4 f_color;

                void main( void ) {
                    /* we can test depth values with this.*/
                    f_color = vec4(vec3(gl_FragCoord.z), 1.0); 
                }
            `;

            let frag_shader = gl.createShader( gl.FRAGMENT_SHADER );
            gl.shaderSource( frag_shader, fragment_source );
            gl.compileShader( frag_shader );

            let shader_program = gl.createProgram();
            gl.attachShader( shader_program, vert_shader );
            gl.attachShader( shader_program, frag_shader );
            gl.linkProgram( shader_program );

            gl.useProgram( shader_program );

            gl.clearColor( 0.9, 0.9, 1.0, 1 );
            gl.enable( gl.DEPTH_TEST );
            gl.clear( gl.COLOR_BUFFER_BIT );

            //This line uses Grant's cube mesh
            let loadedMesh = Mesh.box(gl,shader_program,1,1,1);

            //load mesh from obj file
            /*Mesh.from_obj_file(gl,'cube.obj',shader_program,function(meshToLoad){
                loadedMesh = meshToLoad;
                console.log('Mesh loaded:',loadedMesh);
            });
            */
            
			function set_uniform_matrix4(gl,program,name,data){
				const loc=gl.getUniformLocation(program,name);
				gl.uniformMatrix4fv(loc,true,data);
			}
			
            gl.viewport( 0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight );

            //calculate perspective, return frustum
            function perspective(fov_x, aspect, near, far){
                let top = Math.tan(fov_x/2)*near;
                let bottom = -top;
                let right = top * aspect;
                let left = -right;
                return Mat4.frustum(left,right,bottom,top,near,far);
            }
            
            //update camera, huge block of input
            function update(){
                const pressedKeys = keys.keys_down_list();

                //position vectors
                let forward = new Vec4(0, 0, 1, 1);
                let up = new Vec4(0, 1, 0, 1);

                //update position based on camera position
                forward = rot_yz.transform_vec(forward);
                forward = rot_xz.transform_vec(forward);
                forward = forward.norm();

                let right = up.cross(forward).norm();
                up = forward.cross(right).norm();

                //Forward
                if(keys.is_key_down('KeyW')){
                    console.log('[W] Forward');
                    translationMatrix = translationMatrix.mul(Mat4.translation(forward.x * 0.01, forward.y * 0.01, forward.z * 0.01));
                }
                
                //Backward
                if(keys.is_key_down('KeyS')){
                    console.log('[S] Backward');
                    translationMatrix = translationMatrix.mul(Mat4.translation(-forward.x * 0.01, -forward.y * 0.01, -forward.z * 0.01));
                }
                
                //Strafe left
                if(keys.is_key_down('KeyA')){
                    console.log('[A] Left');
                    translationMatrix = translationMatrix.mul(Mat4.translation(-right.x * 0.01, -right.y * 0.01, -right.z * 0.01));
                }

                //Strafe right
                if(keys.is_key_down('KeyD')){
                    console.log('[D] Right');
                    translationMatrix = translationMatrix.mul(Mat4.translation(right.x * 0.01, right.y * 0.01, right.z * 0.01));
                }

                //Ascend
                if(keys.is_key_down('Space')){
                    console.log('[Space] Up');
                    translationMatrix = translationMatrix.mul(Mat4.translation(up.x * 0.01, up.y * 0.01, up.z * 0.01));
                }

                //Descend
                if(keys.is_key_down('KeyC')){
                    console.log('[C] Down');
                    translationMatrix = translationMatrix.mul(Mat4.translation(-up.x * 0.01, -up.y * 0.01, -up.z * 0.01));
                }

                //Roll left
                if(keys.is_key_down('KeyQ')){
                    console.log('[Q] Roll left');
                    rot_xy = rot_xy.mul(Mat4.rotation_xy(-0.005));
                }

                //Roll right
                if(keys.is_key_down('KeyE')){
                    console.log('[E] Roll right');
                    rot_xy = rot_xy.mul(Mat4.rotation_xy(0.005));
                }

                //Look left
                if(keys.is_key_down('ArrowLeft')){
                    console.log('[<-] Look left');
                    rot_xz = rot_xz.mul(Mat4.rotation_xz(-0.005));
                }

                //Look right
                if(keys.is_key_down('ArrowRight')){
                    console.log('[->] Look right');
                    rot_xz = rot_xz.mul(Mat4.rotation_xz(0.005));
                }

                //Look up
                if(keys.is_key_down('ArrowUp')){
                    console.log('[^] Look up');
                    rot_xz = rot_xz.mul(Mat4.rotation_yz(-0.005));
                }

                //Look down
                if(keys.is_key_down('ArrowDown')){
                    console.log('[\\/] Look down');
                    rot_xz = rot_xz.mul(Mat4.rotation_yz(0.005));
                }
            }
            setInterval(update, DESIRED_MSPT);

            //generate XOR texture
            /*function xor_texture(){
                let data = new Array(256*256*4);
                for(let row=0; row<width; row++){
                    for(let col=0; col<width; col++){
                        let pix = (row*width+col)*4;
                        data[pix]=data[pix+1]=data[pix+2]=row^col;  //set R(p), G(p+1), and B(p+2)
                        data[pix+3]=255;    //set alpha to 255(opaque)
                    }
                }
                return new Uint8Array(data);
            }
            */

            //create and bind texture, then load pixels
            /*let tex=gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, tex);
            gl.texImage2D(
                gl.TEXTURE_2D,0,gl.RGBA,
                256,256,0,
                gl.RGBA, gl.UNSIGNED_BYTE,
                xor_texture()
            );
            */

            //render everything
			function render(now){
                //request frame
                requestAnimationFrame(render);

                //update timing
                let time_delta = (now-last_update)/1000;
                last_update=performance.now();

                //clear color and depth buffers, update matrices
                gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

                //model scalar and translation matrices
                let modelScale = Mat4.scale(1, 1, 1);
                let modelTrans = Mat4.translation(0, 0, 1);
                let modelMatrix = Mat4.translation(0, 0, 1.5);

                //rotation matrices
                //rotate model about the xy plane
                xy_amnt += XY_ROT_SPEED * time_delta;
                xy_amnt %= 1.0;
                modelxy=Mat4.rotation_xy(xy_amnt);

                //rotate model about the xz plane
                xz_amnt += XZ_ROT_SPEED * time_delta;
                xz_amnt %= 1.0;
                modelxz=Mat4.rotation_xz(xz_amnt);

                //rotate model about the yz plane
                yz_amnt += YZ_ROT_SPEED * time_delta;
                yz_amnt %= 1.0;
                modelyz=Mat4.rotation_yz(yz_amnt);

                //perspective setup
                let fov_x = 0.25 * 2 * Math.PI;
                let aspect_ratio = canvas.width/canvas.height;
                let near_plane = 0.25;
                let far_plane = 3.0;
                let projMatrix = perspective(fov_x, aspect_ratio, near_plane, far_plane);

                //the final model we actually render
                model=projMatrix
                    .mul(modelTrans)    //translation matrix
                    //.mul(modelxy)       //xy rotation
                    //.mul(modelyz)       //yz rotation
                    //.mul(modelxz)       //xz rotation
                    .mul(modelScale)    //scalar matrix
                ;

                //camera and view matrices
                let cameraMatrix = translationMatrix
                                    .mul(rot_yz) //Yaw
                                    .mul(rot_xz) //Pitch
                                    .mul(rot_xy) //Roll
                ;
                let viewMatrix = cameraMatrix.inverse();
                let finalMatrix = projMatrix.mul(viewMatrix).mul(modelScale);

                set_uniform_matrix4(gl, shader_program, "modelview", finalMatrix.data);

                //if a mesh is loaded, render it
                if(loadedMesh){
                    loadedMesh.render(gl);                   
                }
			}
			requestAnimationFrame(render);
        </script>
    </body>
</html>